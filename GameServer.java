import javax.swing.*;
import java.awt.geom.*;
import java.awt.*;
import java.io.*;
import java.util.*;
import java.net.*;
import java.awt.event.*;
/**
 *	Manages multiple {@link ServerThread ServerThreads}  and provides a central {@link GameInstance GameInstance} and server time.
**/
public class GameServer extends NetworkingComponent{
	private int numberOfPlayers;
	private final ArrayList<ServerThread> serverThreads;
	private GameInstance gameInstance;
	private int serverTime;
	/**
	 *	Creates a new <code>GameServer</code> associated with a <code>GameInstance</code>.
	 *	@param gameInstance the <code>GameInstance</code> to associate with this <code>GameServer</code>
	**/
	public GameServer(GameInstance gameInstance){
		this.serverThreads = new ArrayList<ServerThread>();
		this.numberOfPlayers = 0;
		this.gameInstance = gameInstance;
		this.serverTime = 180;
	}
	
	private class AcceptConnectionsThread extends Thread{
		private int newClientID;
		private Socket newSocket;
		private ServerSocket serverSocket;
		public void stopAcceptingConnections(){
			try{
				serverSocket.close();
			}catch(IOException e){
				e.printStackTrace();
			}
		}
		public void run(){
			try{
				serverSocket = new ServerSocket(PORT_NUMBER);
				while(numberOfPlayers<4){
					this.newClientID = numberOfPlayers;
					
					System.out.println("Waiting for client . . .");
					this.newSocket = serverSocket.accept();
					ServerThread newConnection = new ServerThread(GameServer.this,newSocket, newClientID);
					
					System.out.println("Player accepted, ID: "+this.newClientID);

					serverThreads.add(newConnection);
					numberOfPlayers++;
					
					newConnection.start();
				}
				serverSocket.close();
			}catch(SocketException e){
				System.out.println("Socket.accept() has been terminated.");
				return;
			}catch(Exception e){
				e.printStackTrace();
			}
		}
	}
	private final AcceptConnectionsThread acceptThread = new AcceptConnectionsThread();
	/**
	 *	Starts a thread which continuously searches for client connections.
	**/
	public void startAcceptingConnections(){
		acceptThread.start();
	}
	/**
	 *	Checks if this <code>GameServer</code> server is currently accepting connections.
	 *	@return <code>true</code> if this <code>GameServer</code> is currently accepting connections, and <code>false</code> otherwise.
	**/
	public boolean isAcceptingConnnections(){
		return acceptThread.isAlive();
	}
	/**
	 *	Stops a thread which continuously searches for client connections, started by {@link #startAcceptingConnections() startAcceptingConnections()}.
	**/
	public void stopAcceptingConnections(){
		acceptThread.stopAcceptingConnections();
	}
	private java.util.Timer timer = new java.util.Timer();
	private TimerTask timerTick = new TimerTask(){
		@Override
		public void run(){
			if(serverTime>0){
				serverTime--;
				System.err.println("serverTime:" + serverTime);
				gameInstance.setTime(serverTime);
			}else if(serverTime==0){
				endGame();
			}
		}
	};
	/**
	 *	Destroys all threads handled by this <code>GameServer</code>.
	**/
	public synchronized void destroy(){
		stopAcceptingConnections();
		timer.cancel();
		for(ServerThread st : serverThreads){
			st.interrupt();
		}
	}
	/**
	 *	Broadcasts a signal to all clients to start the game logic, and starts the server timer.
	**/
	public synchronized void startGame(){
		synchronized(this){
			for(ServerThread st : serverThreads){
				st.sendString("StartGame");
			}
		}
		timer.scheduleAtFixedRate(timerTick,0, 1000);
	}
	/**
	 *	Broadcasts a signal to all clients to stop the game logic.
	**/
	public synchronized void endGame(){
		for(ServerThread st : serverThreads){
			st.sendString("EndGame");
		}
	}
	/**
	 *	Returns a String containing a list of all the clients connected to this server.
	 *	@return a String containing a list of all the clients connected to this server
	**/
	public String getNames(){
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i<numberOfPlayers; i++){
			sb.append(gameInstance.getPlayfield(i).getName());
			sb.append("\n");
		}
		return sb.toString();
	}
	private String getDataBlock(String data, String startToken, String endToken){
		int startIndex = data.indexOf(startToken)+startToken.length()+1;
		int endIndex = data.indexOf(endToken)-1;
		if(startIndex<0 || endIndex<0){
			System.err.println("Bad data received.");
			return "";
		}
		return data.substring(startIndex,endIndex);
	}
	/**
	 *	Processes an instruction from a client.
	 *	@param data an instruction generated by a {@link GameClient GameClient} or {@link ClientThread ClientThread}
	**/
	public synchronized void process(String data){
		String[] dataBlocks = data.split(",");
		int clientID = Integer.parseInt(dataBlocks[0]);
		if(data.indexOf("PlayfieldDataEnd")>=0){
			String playfieldData = getDataBlock(data,"PlayfieldDataBegin","PlayfieldDataEnd");
			if(!playfieldData.equals(""))gameInstance.getPlayfield(clientID).loadData(playfieldData);
		}else if(dataBlocks[1].equals("sendGarbage")){
			for(ServerThread st : serverThreads){
				if(st.getClientID()==clientID) continue;
				st.sendString("addGarbage,"+dataBlocks[2]);
			}
		}
	}
	/**
	 *	Obtains the String representation of the server's central game instance.
	 *	@return a String representation of the {@link GameInstance GameInstance} stored on the server.
	**/
	public synchronized String getSendableData(){
		return gameInstance.toString();
	}

}