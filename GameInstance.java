import java.util.*;
import java.util.concurrent.*;
/**
 *	The <code>GameInstance</code> is a collection of {@link Playfield Playfield} objects, and a game time value.
**/
public class GameInstance{
	private int numPlayers;
	private int gameTime;
	ConcurrentHashMap<Integer, Playfield> playfields;
	/**
	 *	Creates a new <code>GameInstance</code>.
	**/
	public GameInstance(){
		this.playfields = new ConcurrentHashMap<Integer, Playfield>();
		this.numPlayers = 0;
		this.gameTime = 180;
	}
	/**
	 *	Sets the game time of this <code>GameInstance</code>.
	 *	@param newTime the new time in seconds.
	**/
	public synchronized void setTime(int newTime){
		gameTime = newTime;
	}
	/**
	 *	Returns the game time of this <code>GameInstance</code>.
	 *	@return the game time of this <code>GameInstance</code>.
	**/
	public synchronized int getTime(){
		return gameTime;
	}
	/**
	 *	Class representing a single <code><name,score></code> entry.
	**/
	public class Record implements Comparable{
		/**
		 *	The player name associated with this record.
		**/
		public String playerName;
		/**
		 *	The score associated with this record.
		**/
		public int score;
		/**
		 *	Creates a new <code>Record</code> with a given player name and score.
		 *	@param playerName the player name associated with this record
		 *	@param score the score associated with this record
		**/
		public Record(String playerName, int score){
			this.playerName = playerName;
			this.score = score;
		}
		/**
		 *	Compares two records, such that their default ordering is <b>descending score</b>.
		**/
		@Override
		public int compareTo(Object other){
			return ((Record)other).score - this.score;
		}
	}
	/**
	 *	Returns a sorted <code>ArrayList</code> of <code>Record</code>s reflecting the {@link Playfield Playfield} objects in this <code>GameInstance</code>.
	 *	@return an sorted <code>ArrayList</code> of <code>Record</code>s representing the state of this <code>GameInstance</code>.
	**/
	public synchronized ArrayList<Record> getRecords(){
		ArrayList<Record> records = new ArrayList<Record>();
		for(int i = 0; i<numPlayers; i++){
			records.add( new Record(
				playfields.get(i).getName(),
				playfields.get(i).getScore()
			));
		}
		Collections.sort(records);
		return records;
	}
	/**
	 *	Adds a new player to this <code>GameInstance</code>.
	**/
	public synchronized void addPlayer(){
		playfields.put(numPlayers,new Playfield());
		numPlayers++;
	}
	/**
	 *	Returns the number of players in this <code>GameInstance</code>.
	 *	@return the number of players in this <code>GameInstance</code>.
	**/
	public synchronized int getNumberOfPlayers(){
		return numPlayers;
	}
	/**
	 *	Obtains the <code>Playfield</code> associated with a given player ID.
	 * <p> If no such playfield exists, a new playfield is created and returned.
	 * @param playerID a player ID
	 * @return a <code>Playfield</code> associated with the given player ID
	**/
	public synchronized Playfield getPlayfield(int playerID){
		while(playfields.get(playerID)==null){addPlayer();}
		return playfields.get(playerID);
	}

	private String getDataBlock(String data, String startToken, String endToken){
		int startIndex = data.indexOf(startToken)+startToken.length()+1;
		int endIndex = data.indexOf(endToken)-1;
		return data.substring(startIndex,endIndex);
	}
	/**
	 *	Sets the data of this <code>GameInstance</code> based on a <code>String</code> generated by {@link #toString() toString()}.
	 *	<p> The data currently in this <code>GameInstance</code> will be overwritten.
	 *	<p> If <code>playerIDToOmit</code> is not <code>null</code>, the data under the player ID specified by <code>playerIDToOmit</code> will <b>NOT</b> be overwritten.
	 *	@param objectData the string to be parsed and loaded as <code>GameInstance</code> data.
	 *	@param playerIDToOmit if this parameter is not <code>null</code>, data for this player ID will be ignored.
	**/
	public synchronized void loadData(String objectData, Integer playerIDToOmit){
		gameTime = Integer.parseInt(getDataBlock(objectData, "gameTimeStart", "gameTimeEnd"));
		String[] dataBlocks = objectData.split("PlayerData,");
		for(int i = 1; i<dataBlocks.length; i++){
			int playerID = Integer.parseInt(dataBlocks[i].split(",")[0]);
			if(playerIDToOmit==null || (playerIDToOmit!=null && playerIDToOmit!=playerID)){
				while(playfields.get(playerID)==null){addPlayer();}
				playfields.get(playerID).loadData(getDataBlock(dataBlocks[i],"PlayfieldDataBegin","PlayfieldDataEnd"));
			}
		}
	}
	/**
	 *	Generates a <code>String</code> containing all the data of this <code>GameInstance</code>.
	 *	<p> This string returned by this function can be parsed by  {@link #loadData(String,Integer) loadData(String objectData, Integer playerIDToOmit)}.
	 *	@return A <code>String</code> which represents the data of this <code>GameInstance</code>
	**/
	@Override
	public synchronized String toString(){
		StringBuilder sb = new StringBuilder();
		sb.append("gameTimeStart,");
		sb.append(gameTime);
		sb.append(",gameTimeEnd,");
		for(int i = 0; i<numPlayers; i++){
			if(i>0) sb.append(",");
			sb.append("PlayerData,");
			sb.append(i);
			sb.append(",PlayfieldDataBegin,");
			sb.append(playfields.get(i).toString());
			sb.append(",PlayfieldDataEnd");
		}
		return sb.toString();
	}
}
